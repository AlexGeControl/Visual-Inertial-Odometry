# Bundle Adjustment in the Large, Custom G2O Node with Analytic Jacobian

---

## Derivation of Analytic Jacobian

In this section the analytic expression of Jacobians needed for custom G2O node be derived. 

The derivation is based on `SymPy` inside `Jupyter Lab`.

### Point-to-Pixel Projection

For BAL dataset a pinhole camera model is used. The parameters we estimate for each camera are: 

* Rotation `R`
* Translation `t`

Here we treat the following parameters as fixed:

* Focal length `f`
* Two radial distortion parameters `k1` and `k2`. 

The formula for projecting a 3D point X into a camera using R,t,f,k1,k2 is:

* P  =  R * X + t       (conversion from world to camera coordinates)
* p  = -P / P.z         (perspective division)
* p' =  f * r(p) * p    (conversion to pixel coordinates)

where P.z is the third (z) coordinate of P. 

In the last equation, r(p) is a function that computes a scaling factor to undo the radial distortion:
* r(p) = 1.0 + k1 * ||p||^2 + k2 * ||p||^4.

This gives a projection in pixels, where 

* The `origin of the image` is `the center of the image`
* The `positive x-axis` points `right`
* The `positive y-axis` points `up` 

(in addition, in the camera coordinate system, the positive z-axis points backwards, so the camera is looking down the negative z-axis, as in OpenGL).

### Intermediate Variables

For derivation `landmark coordinates in camera frame, X`, is used as `intermediate variable`.

---

## Results

### Jacobian with Respect to Intermediate Variables, Point Coordinates in Camera Frame

Using the [Jupyter notebook](bal-jacobian.ipynb), the C++ Eigen expression can be shown as:

```c++
// this is the analytic Jacobian expression generated by SymPy
double P_X_2 = pow(X, 2);
double P_Y_2 = pow(Y, 2);
double P_Z_2 = pow(Z, 2);
double P_Z_4 = pow(Z, 4);
double P_Z_5 = pow(Z, 5);
double P_Z_6 = pow(Z, 6);

Eigen::Matrix<double, 2, 3> JP;

JP(0, 0) = -f*(2*P_X_2*(P_Z_2*k1 + 2*k2*(P_X_2 + P_Y_2)) + P_Z_4 + (P_X_2 + P_Y_2)*(P_Z_2*k1 + k2*(P_X_2 + P_Y_2)))/P_Z_5;
JP(0, 1) = -2*P_X*P_Y*f*(P_Z_2*k1 + 2*k2*(P_X_2 + P_Y_2))/P_Z_5;
JP(0, 2) = P_X*f*(P_Z_4 + (P_X_2 + P_Y_2)*(P_Z_2*k1 + k2*(P_X_2 + P_Y_2)) + 2*(P_X_2 + P_Y_2)*(P_Z_2*k1 + 2*k2*(P_X_2 + P_Y_2)))/P_Z_6;
JP(1, 0) = -2*P_X*P_Y*f*(P_Z_2*k1 + 2*k2*(P_X_2 + P_Y_2))/P_Z_5;
JP(1, 1) = -f*(2*P_Y_2*(P_Z_2*k1 + 2*k2*(P_X_2 + P_Y_2)) + P_Z_4 + (P_X_2 + P_Y_2)*(P_Z_2*k1 + k2*(P_X_2 + P_Y_2)))/P_Z_5;
JP(1, 2) = P_Y*f*(P_Z_4 + (P_X_2 + P_Y_2)*(P_Z_2*k1 + k2*(P_X_2 + P_Y_2)) + 2*(P_X_2 + P_Y_2)*(P_Z_2*k1 + 2*k2*(P_X_2 + P_Y_2)))/P_Z_6;
```

### Jacobian with Respect to Camera Intrinsics

Using the [Jupyter notebook](bal-jacobian.ipynb), the C++ Eigen expression can be shown as:

```c++
// this is the analytic Jacobian expression generated by SymPy
double P_X_2 = pow(X, 2);
double P_Y_2 = pow(Y, 2);
double P_Z_2 = pow(Z, 2);
double P_Z_3 = pow(Z, 3);
double P_Z_4 = pow(Z, 4);
double P_Z_5 = pow(Z, 5);

Eigen::Matrix<double, 2, 3> JI;

JI(0, 0) = -P_X*(P_Z_4 + (P_X_2 + P_Y_2)*(P_Z_2*k1 + k2*(P_X_2 + P_Y_2)))/P_Z_5;
JI(0, 1) = -P_X*f*(P_X_2 + P_Y_2)/P_Z_3;
JI(0, 2) = -P_X*f*(P_X_2 + P_Y_2)**2/P_Z_5;
JI(1, 0) = -P_Y*(P_Z_4 + (P_X_2 + P_Y_2)*(P_Z_2*k1 + k2*(P_X_2 + P_Y_2)))/P_Z_5;
JI(1, 1) = -P_Y*f*(P_X_2 + P_Y_2)/P_Z_3;
JI(1, 2) = -P_Y*f*(P_X_2 + P_Y_2)**2/P_Z_5;
```

