
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <iostream>
#include <iomanip>
#include <thread>

#include <boost/filesystem.hpp>
#include <boost/regex.hpp>
#include <boost/lexical_cast.hpp>

#include <cv.h>
#include <opencv2/opencv.hpp>
#include <highgui.h>
#include <eigen3/Eigen/Dense>

#include "System.h"

#include "utility/CSVParser.h"

using namespace std;
using namespace cv;
using namespace Eigen;

const int nDelayTimes = 2;
string sData_path = "/home/dataset/EuRoC/MH-05/mav0/";
string sConfig_path = "../config/";

std::shared_ptr<System> pSystem;

// publish IMU data generated by vio_data_simulation
void PubImuData(void) 
{
	// const std::string filename("../../simulator/bin/imu_pose_noise.txt");
	const std::string filename("../../simulator/bin/imu_pose.txt");

	std::vector<IMUMeasurement> imu_measurements;

	// config IMU data parser:
    io::CSVReader<7> imu_data(filename);
    imu_data.read_header(
        io::ignore_extra_column, 
        "timestamp",
        "gyro_x", "gyro_y", "gyro_z",
        "acc_x", "acc_y", "acc_z"
    );

    double timestamp;
    double gyro_x, gyro_y, gyro_z;
    double acc_x, acc_y, acc_z;

    while(
        imu_data.read_row(
            timestamp, 
            gyro_x, gyro_y, gyro_z,
            acc_x, acc_y, acc_z
        )
    ){
		Vector3d gyr(gyro_x, gyro_y, gyro_z);
		Vector3d acc(acc_x, acc_y, acc_z);

		IMUMeasurement imu_measurement;

		imu_measurement.timestamp = timestamp;
		imu_measurement.gyr = gyr;
		imu_measurement.acc = acc;

		imu_measurements.push_back(imu_measurement);
    }

	// sort IMU measurements using timestamp
	std::sort(
		imu_measurements.begin(), 
		imu_measurements.end(), 
		[](const IMUMeasurement &x, const IMUMeasurement &y) -> bool
		{ 
			return x.timestamp < y.timestamp; 
		}
	);

	for (const IMUMeasurement &imu_measurement: imu_measurements) {
		pSystem->PubImuData(
			imu_measurement.timestamp, 
			imu_measurement.gyr,
			imu_measurement.acc
		);
		usleep(5000*nDelayTimes);
	}
}

struct KeyFrameWithSeqID {
	std::string seq;
	std::string path;

	KeyFrameWithSeqID(void) {}
} ;

void PubImageData(void)
{	
	const std::string pathname("../../simulator/bin/keyframe");
	const boost::regex filter( "all_points_(.*)\.txt");
	
	boost::filesystem::path path(pathname);

	try
	{
		if (boost::filesystem::exists(path)) {
      		if (boost::filesystem::is_regular_file(path)) {
				std::cerr << "Please specify the root directory of generated keyframe observations." << std::endl;
			} else if (boost::filesystem::is_directory(path)) {
				std::vector<KeyFrameWithSeqID> keyframes;

				// iterate through keyframe directory:
				boost::filesystem::directory_iterator terminator;
				for(
					boost::filesystem::directory_iterator it(path); 
					it != terminator; 
					++it 
				) {
					// only collect landmark observations:
					boost::smatch what;
    				if (
						!boost::regex_match(
							it->path().filename().string(), 
							what, 
							filter, 
							boost::match_extra
						)
					) {
						continue;
					}
						
					KeyFrameWithSeqID keyframe;

					keyframe.seq = what[1];
					keyframe.path = it->path().string();

    				keyframes.push_back(keyframe);
				}

				// sort camera observations using seq. ID:
        		std::sort(
					keyframes.begin(), 
					keyframes.end(), 
    				[](const KeyFrameWithSeqID &x, const KeyFrameWithSeqID &y) -> bool
					{ 
    					return boost::lexical_cast<size_t>(x.seq) < boost::lexical_cast<size_t>(y.seq); 
					}
				);
				
				// publish keyframes:
				for (
					std::vector<KeyFrameWithSeqID>::const_iterator it(keyframes.begin()); 
					it != keyframes.end(); 
					++it
				) {
					KeyFrame keyframe;

					// config keyframe data parser:
					io::CSVReader<6> keyframe_data(it->path);
					keyframe_data.read_header(
						io::ignore_extra_column, 
						"timestamp",
						"id",
						"x_normalized", "y_normalized",
						"u", "v"
					);

					int id;
					double x_normalized, y_normalized;
					double u, v;

					while(
						keyframe_data.read_row(
							keyframe.timestamp, 
							id, 
							x_normalized, y_normalized,
							u, v
						)
					){
						Landmark landmark;

						landmark.id = id;
						landmark.p_normalized = Eigen::Vector2d(x_normalized, y_normalized);
						landmark.p_image = Eigen::Vector2d(u, v);

						keyframe.landmarks.push_back(landmark);
					}

					pSystem->PubImageData(keyframe.timestamp, keyframe);
					usleep(50000*nDelayTimes);
				}
			} else {
				std::cout << "Unknown input type. Aborted." << std::endl;
			}
    	}
    	else {
			std::cout << "Input path does not exist." << std::endl;
		}
	}
	catch (const boost::filesystem::filesystem_error& ex) {
    	std::cout << ex.what() << std::endl;
  	}
}

int main(int argc, char **argv)
{
	if(argc != 3)
	{
		cerr << "./run_vio_simulation PATH_TO_VIO_SIMULATION_DATA PATH_TO_CONFIG \n" 
			<< "For example: ./run_vio_simulation . ../config/"<< endl;
		return EXIT_FAILURE;
	}

	sData_path = argv[1];
	sConfig_path = argv[2];

	pSystem.reset(new System(sConfig_path));
	
	std::thread thd_BackEnd(&System::ProcessBackEnd, pSystem);
		
	// sleep(5);
	std::thread thd_PubImuData(PubImuData);
	std::thread thd_PubImageData(PubImageData);
#ifdef __linux__	
	std::thread thd_Draw(&System::Draw, pSystem);
#elif __APPLE__
	DrawIMGandGLinMainThrd();
#endif
	thd_PubImuData.join();
	thd_PubImageData.join();

	// thd_BackEnd.join();
	// thd_Draw.join();

	std::cout << "main end... see you ..." << std::endl;

	return EXIT_SUCCESS;
}
